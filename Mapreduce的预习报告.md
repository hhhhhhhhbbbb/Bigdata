# Mapreduce的预习报告



---
##1.1 为什么要学习Mapreduce

       1.单机资源受限，比如CPU，磁盘
       2.分布式计算的程序的复杂度特别高，难度大 mapreduce就是解决以上问题的：  
        1.利用集群的所有cpu，所有内存，所有磁盘
        2. mapreduce就将公共的功能的开发封装成了框架，不需要开发人员操心，开发人员只需要关注具体的业务逻辑。

##1.2 Mapreduce的简介
###1.2.1 简介

    1. mapreduce是hadoop的三大重要模块之一
    2. mapreduce是一个并发的计算和分析框架，用于计算和分析分布式文件系统上的大数据集。
    3. 将计算划分为两个阶段：一个map(映射)阶段，一个reduce(归约)阶段
    4. 该框架的开发灵感来源于google的《mapreduce》论文
    5. 方便开发人员在不会分布式计算的情况下，开发和运行相关计算程序。

###1.2.2 优缺点
 

    1.优点
    - 适合离线数据处理
    - mapreduce编程简单
    - 扩展性良好
    - 高容错性
    2.缺点
    - 不适合实时计算(实时计算：毫秒级别/秒级别，离线计算:秒级别以上)
    - 不适合流式计算(mapreduce处理的数据是静态的，不是流式的数据)
    - 不适合DAG(有向图)计算

##1.3 Mapreduce的核心思想（重点）

     简单的一句话概括：“移动计算而非移动数据”。
    整理：
    程序员将自己写好的业务逻辑代码和mr自带的一些组件打包成计算程序，移动到有数据存储的节点上，这样可以利用多节点的cpu的并发能力，提高计算效率（怎么提高的？一减少数据移动的开销，二利用了并发计算原理）
    mapreduce是分为两个阶段，map阶段处理的是块文件(原始文件)，计算后的结果存储本地磁盘，reduce阶段要跨节点fetch属于自己要处理的数据，计算后的结果存储到hdfs上(当然也可以存储到客户端所在的本地磁盘)

##1.4 Mapreduce的阶段介绍（重点）
###1.4.1 Map阶段

      map阶段处理的是原始数据，也就是块文件(处理的是本存储节点上的数据)。会将处理的块文件，以切片的形式进行逻辑运算。通过映射关系进行一一映射。map阶段会有多个mapTask,这些任务并发运行，互不干扰 默认情况下，按行进行映射成键值对， 原始块文件
      |
      |
      K1,V1(有N个kv对，K1是行偏移量,v1是行记录，也就是行内容)
      |
      |map方法
      |
      | 每一对k1v1都会调用一次map方法，在map方法里进行处理，形成K2V2
      |  
      K2，V2  (存储到本地磁盘)

###1.4.2 Reduce阶段

     reduce阶段处理的是map阶段计算出来的数据(临时数据)，reduce阶段也会有多个reduceTask,并发运行，互不干扰。reduce处理的数据通常都是要跨节点fetch属于自己处理的数据。
    fetch属于自己的一堆K2,v2，先形成<K2,<v2,v2,v2>>
             |
             |
           reduce方法
             |
    	     |  同一个k2调用一次reduce方法，在reduce方法里进行处理，形成K3,v3
    	     |
           K3,V3(存储到HDFS上)

##1.5 Mapreduce的编程模型
###1.5.1 自定义Mapper类型

    1. 自定义类名，继承Mapper类型
    2. 定义K1,V1,K2,V2的泛型
    3. 重写map方法

###1.5.2 自定义Reducer类型

    1. 自定义类名，继承Reducer类型
    2. 定义K2,V2,K3,V3的泛型
    3. 重写reduce方法

###1.5.3 自定义Driver类型

    1. 获取job对象
    2. 指定驱动类型
    3. 指定Mapper类型和Reducer类型
    4. 指定map阶段的K2,V2类型
    5. 指定reduce阶段的K3,V3类型
    6. 指定分区的数量.....
    7. 指定要统计的文件的输入路径
    8. 指定要输出的位置路径
    9. 提交程序

